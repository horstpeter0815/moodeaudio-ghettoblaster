<!--
/*
 * SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright 2014 The moOde audio player project / Tim Curtis
*/
-->
<div id="container">
<div class="container">
	<h1 class="snd-config">Audio</h1>

	<form class="form-horizontal" method="post">
		<legend>Audio Output</legend>
		<p class="sub-legend">
			Select from Pi HDMI/Headphone, I2S or USB audio devices.
			These settings cannot be changed when outputting to a Bluetooth speaker or when Multiroom Sender or Receiver are On.
		</p>

		<div class="control-group">
			<label class="control-label" for="output-device">Output device</label>
			<div class="controls">
                <select id="output-device" name="output_device_cardnum" class="config-select-large" onchange="autoClick('#btn-set-output-device');" $_output_device_btn_disabled>
					$_select[device]
                </select>
				<button id="btn-set-output-device" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_output_device" value="novalue" $_output_device_btn_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="nop" value="novalue" $_output_device_btn_disabled>Scan</i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-output-device" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-output-device" class="config-help-info">
					The list shows the ALSA card number and assigned audio device or "empty".
					The SCAN button refreshes the list to pick up newly connected USB audio devices.
				</span>
			</div>

			<label class="control-label" for="mixer-type">Volume type</label>
            <div class="controls">
                <select id="mixer-type" name="mixer_type" class="config-select-large" onchange="autoClick('#btn-set-mixer-type');" $_volume_type_btn_disabled>
					$_select[mixer_type]
                </select>
				<button id="btn-set-mixer-type" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_volume_type" value="novalue" $_volume_type_btn_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-mixer-type" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-mixer-type" class="config-help-info">
					Volume type used by MPD.<br>
					<b>- Hardware:</b> Audio device on-chip volume controller.<br>
					<b>- Software:</b> MPD software volume (32 bit float with dither).<br>
					<b>- Fixed (0dB):</b> Output 100% volume. Assumes a downstream volume control is used.<br>
					<b>- CamillaDSP:</b> CamillaDSP software volume (64 bit float with dither).
				</span>
				<span class="config-help-static">
					Set volume to a low level before changing these options.
					$_software_and_dsd_warning
				</span>
			</div>

			<div class="$_camilladsp_volume_range_hide">
				<label class="control-label" for="camilladsp-volume-range">Volume range</label>
				<div class="controls">
					<select id="camilladsp-volume-range" class="config-select-large" name="camilladsp_volume_range" onchange="autoClick('#btn-set-camilladsp-volume-range');">
						$_select[camilladsp_volume_range]
					</select>
					<button id="btn-set-camilladsp-volume-range" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_camilladsp_volume_range" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
					<a aria-label="Help" class="config-info-toggle" data-cmd="info-camilladsp-volume-range" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
					<span id="info-camilladsp-volume-range" class="config-help-info">
						This value represents the difference between the maximum loudness and background noise level.
						It is used to generate the volume curve which determines the loudness at each point on the CamillaDSP volume slider and moOde volume knob.
					</span>
				</div>
			</div>

			<label class="control-label" for="alsa-empty-retry">Device ready wait</label>
			<div class="controls">
                <select id="alsa-empty-retry" name="alsa_empty_retry" class="config-select-large" onchange="autoClick('#btn-set-alsa-empty-retry');">
					$_select[alsa_empty_retry]
                </select>
				<button id="btn-set-alsa-empty-retry" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_alsa_empty_retry" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-alsa-empty-retry" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-alsa-empty-retry" class="config-help-info">
					During start up, wait up to the specified number of minutes for the Output device to become ready.
				</span>
			</div>

			<!-- Ghetto Crew Flat EQ (Factory Settings) -->
			<div class="config-horiz-rule"></div>
			<div class="control-group">
				<label class="control-label" for="ghettoblaster-flat-eq">Flat EQ (Factory Settings)</label>
				<div class="controls">
					<label class="checkbox">
						<input type="checkbox" id="ghettoblaster-flat-eq" 
							   onchange="toggleGhettoBlasterFlatEQ(this.checked);"
							   $_ghettoblaster_flat_eq_checked>
						Enable Flat EQ (Kompensiert Frequency Response fÃ¼r gerade Linie)
					</label>
					<a aria-label="Help" class="config-info-toggle" data-cmd="info-flat-eq" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
					<span id="info-flat-eq" class="config-help-info">
						Flat EQ Preset fÃ¼r Ghetto Blaster System.<br>
						<b>- Kompensiert:</b> Frequency Response Schwankungen<br>
						<b>- Ziel:</b> Gerade Linie fÃ¼r alle Treiber kombiniert<br>
						Factory Settings fÃ¼r optimalen Sound.
					</span>
				</div>
			</div>

			<!-- Room Correction (Roon-inspiriert) -->
			<div class="config-horiz-rule"></div>
			<div class="control-group">
				<label class="control-label" for="room-correction-preset">Room Correction</label>
				<div class="controls">
					<select id="room-correction-preset" class="config-select-large" name="room_correction_preset" onchange="autoClick('#btn-set-room-correction');">
						$_select[room_correction_preset]
					</select>
					<button id="btn-set-room-correction" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_room_correction" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
					<a data-toggle="modal" href="#room-correction-wizard-modal"><button class="btn btn-primary btn-medium config-btn" type="button">Run Wizard</button></a>
					<button class="btn btn-primary btn-small config-btn" type="button" id="btn-room-correction-ab" onclick="toggleRoomCorrectionAB()">A/B Test</button>
					<a aria-label="Help" class="config-info-toggle" data-cmd="info-room-correction" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
					<span class="config-help-static">
						Current: $_room_correction_preset_value
					</span>
					<span id="info-room-correction" class="config-help-info">
						Room Correction mit Convolution Filters (FIR).<br>
						<b>- Preset:</b> WÃ¤hle gespeicherten Filter aus.<br>
						<b>- Wizard:</b> Starte Room Correction Wizard fÃ¼r Messung am HÃ¶rplatz.<br>
						<b>- A/B Test:</b> Toggle Filter Ein/Aus fÃ¼r Vergleich.<br>
						Funktioniert nahtlos ohne Unterbrechung.
					</span>
				</div>
			</div>

			<div class="config-horiz-rule"></div>

			<label class="control-label" for="i2sdevice">Named I2S device</label>
			<div class="controls">
				<select id="i2sdevice" class="config-select-large" name="i2sdevice" onchange="autoClick('#btn-set-i2sdevice');" $_i2sdevice_btn_disable>
					$_i2s[i2sdevice]
				</select>
				<button id="btn-set-i2sdevice" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_i2s_device" value="novalue" $_i2sdevice_btn_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
			</div>
			<label class="control-label" for="i2soverlay">or DT overlay</label>
			<div class="controls">
				<select id="i2soverlay" class="config-select-large" name="i2soverlay" onchange="autoClick('#btn-set-i2soverlay');" $_i2soverlay_btn_disable>
					$_i2s[i2soverlay]
				</select>
				<button id="btn-set-i2soverlay" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_i2s_overlay" value="novalue" $_i2soverlay_btn_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<span class="config-help-static">
					After setting a device or overlay, reboot and then select the device from the Output device list.
				</span>
			</div>

			<label class="control-label" for="drvoptions">Driver options</label>
			<div class="controls">
				<select id="drvoptions" class="config-select-large" name="drvoptions" onchange="autoClick('#btn-set-drvoptions');" $_driveropt_btn_disable>
					$_select[drvoptions]
				</select>
				<button id="btn-set-drvoptions" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_drvoptions" value="novalue" $_driveropt_btn_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-drvoptions" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-drvoptions" class="config-help-info">
					<b>slave:</b> If enabled, Boss and MiniBOSS DAC operate in slave mode required by Kali reclocker.<br>
					<b>glb_mclk:</b> If enabled, Kali MCLK is used and PLL for Piano 2.1 is disabled for best SQ.<br>
                </span>
			</div>

			<label class="control-label">Chip options</label>
			<div class="controls">
				<a href="chp-config.php" $_chip_link_disable><button class="btn btn-primary btn-medium config-btn" $_chip_btn_disable>Edit</button></a>
			</div>

			<div class="$_pi_audio_driver_hide">
				<div class="config-horiz-rule"></div>
				<label class="control-label" for="pi-audio-driver">Integrated audio</label>
				<div class="controls">
					<select id="pi-audio-driver" class="config-select-large" name="pi_audio_driver" onchange="autoClick('#btn-set-pi-audio-driver');">
						$_select[pi_audio_driver]
					</select>
					<button id="btn-set-pi-audio-driver" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_pi_audio_driver" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
					<a aria-label="Help" class="config-info-toggle" data-cmd="info-pi-audio-driver" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
					<span id="info-pi-audio-driver" class="config-help-info">
						<b>Kernel mode:</b> Default vc4-kms-v3d driver for advanced HDMI capabilities.<br>
						<b>Firmware mode:</b> Legacy snd-bcm2835 driver to support Pi Headphone only configuration. No other audio, video or system features are supported.
					</span>
				</div>
			</div>
		</div>

		<legend>ALSA Options</legend>
		<p class="sub-legend">
			Advanced Linux Sound Architecture (ALSA) is a software framework and part of the Linux kernel that provides an application programming interface (API) for sound card device drivers and audio applications.
		</p>

		<div class="control-group">
			<label class="control-label" for="alsavolume-max">Max volume</label>
			<div class="controls">
				<input class="config-input-large" $_alsavolume_max_readonly type="number" maxlength="3" min="1" max="100" id="alsavolume-max" name="alsavolume_max" value="$_alsavolume_max" required $_alsavolume_max_disable>
				<button class="btn btn-primary btn-small config-btn-set btn-submit status-msg" type="submit" name="update_alsavolume_max" value="novalue" $_alsavolume_max_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-alsavolume-max" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				$_alsavolume_max_msg
				<span id="info-alsavolume-max" class="config-help-info">
					This establishes the ALSA 0dB level when volume type is set to Software, Fixed or CamillaDSP, or when any Renderers are active.
					Alsamixer volume units (1 to 100) are used.
				</span>
			</div>

			<label class="control-label" for="alsa-output-mode">Output mode</label>
			<div class="controls">
				<select id="alsa-output-mode" class="config-select-large" name="alsa_output_mode" onchange="autoClick('#btn-set-alsa-output-mode');" $_alsa_output_mode_disable>
					$_select[alsa_output_mode]
				</select>
				<button id="btn-set-alsa-output-mode" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_alsa_output_mode" value="novalue" $_alsa_output_mode_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-alsa-output-mode" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span class="config-help-static">
					ALSA: $_alsa_output_mode
				</span>
				<span id="info-alsa-output-mode" class="config-help-info">
					<b>Default: </b>ALSA "plughw" plugin which performs format conversions if needed to match audio device requirements.<br>
					<b>Direct: </b>ALSA "hw" plugin which does not perform format conversions. The audio device must accept the given format.<br>
					<b>IEC958: </b>ALSA "iec958" plugin which provides IEC958_SUBFRAME_LE format for HDMI audio.<br>
					These modes apply to MPD, Bluetooth (inbound), AirPlay, Spotify Connect, Squeezelite and the Equalizers.
				</span>
			</div>

			<div class="$_pcm5122_oversampling_hide">
				<label class="control-label" for="pcm5122-oversampling">Oversampling Filter</label>
				<div class="controls">
					<select id="pcm5122-oversampling" class="config-select-large" name="pcm5122_oversampling" onchange="autoClick('#btn-set-pcm5122-oversampling');" $_pcm5122_oversampling_disable>
						$_select[pcm5122_oversampling]
					</select>
					<button id="btn-set-pcm5122-oversampling" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_pcm5122_oversampling" value="novalue" $_pcm5122_oversampling_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
					<a aria-label="Help" class="config-info-toggle" data-cmd="info-pcm5122-oversampling" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
					<span id="info-pcm5122-oversampling" class="config-help-info">
						Select the oversampling filter algorithm for PCM5122-based DACs (e.g., HiFiBerry AMP100).<br>
						<b>Bezier 1:</b> Linear phase filter with smooth frequency response.<br>
						<b>Bezier 2:</b> Alternative Bezier filter variant.<br>
						<b>Linear:</b> Linear interpolation filter.<br>
						<b>Minimum Phase:</b> Minimum phase filter for natural sound.<br>
						Different filters may affect audio characteristics. Experiment to find your preference.
					</span>
					<span class="config-help-static">
						Current: $_pcm5122_oversampling_value
					</span>
				</div>
			</div>

			<label class="control-label">Loopback</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-alsa-loopback" for="toggle-alsa-loopback-2">ON </label>$_select[alsa_loopback_on]
					<label class="toggle-radio toggle-alsa-loopback" for="toggle-alsa-loopback-1">OFF</label>$_select[alsa_loopback_off]
				</div>
				<button id="btn-set-alsa-loopback" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_alsa_loopback" value="novalue" $_alsa_loopback_disable><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-alsa-loopback" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-alsa-loopback" class="config-help-info">
					The Loopback device provides a copy of the PCM output stream that can be accessed by reading "hw:Loopback,1,0".<br>
					<b>-</b> Loopback is not supported for CamillaDSP.<br>
					<b>-</b> Loopback requires > 44.1K for Pi-3 HDMI/Headphone (does not apply if Multiroom Sender is on).
                </span>
			</div>

			<div $_feat_multiroom">
				<label class="control-label">Multiroom</label>
				<div class="controls">
					<a href="trx-config.php"><button class="btn btn-primary btn-medium config-btn">Configure</button></a>
					<span class="config-help-static">
						Set up multiroom sender and receivers.
		            </span>
				</div>
			</div>
		</div>

		<legend>MPD Options</legend>
		<p class="sub-legend">
			Music Player Daemon (MPD) is a flexible, powerful, server-side application for playing music and is the primary audio application in moOde. MPD settings including DSD, SoX resampling, audio buffers and others are configured via the EDIT button.
		</p>

		<div class="config-horiz-rule">General</div>
		<div class="control-group">
			<label class="control-label">MPD settings</label>
			<div class="controls">
				<a href="mpd-config.php"><button class="btn btn-primary btn-medium config-btn">Edit</button></a>
			</div>

			<div class="controls">
				<a data-toggle="modal" href="#mpd-restart"><button class="btn btn-medium btn-primary config-btn">Restart</button></a>
				<span class="config-btn-after">MPD</span>
			</div>

			<label class="control-label">Autoplay after start</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-autoplay" for="toggle-autoplay-2">ON </label>$_select[autoplay_on]
					<label class="toggle-radio toggle-autoplay" for="toggle-autoplay-1">OFF</label>$_select[autoplay_off]
				</div>
				<button id="btn-set-autoplay" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_autoplay" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-autoplay" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-autoplay" class="config-help-info">
					Start auto-shuffle random play if it was previously active or play last played item.
                </span>
			</div>

			<label class="control-label">Metadata file</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-extmeta" for="toggle-extmeta-2">ON </label>$_select[extmeta_on]
					<label class="toggle-radio toggle-extmeta" for="toggle-extmeta-1">OFF</label>$_select[extmeta_off]
				</div>
				<button id="btn-set-extmeta" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_extmeta" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-extmeta" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-extmeta" class="config-help-info">
					Maintain enhanced metadata for the currently playing song or station in the /var/local/www/currentsong.txt file. This file is updated within three seconds after any metadata updates on the UI.
                </span>
			</div>
		</div>

		<div class="config-horiz-rule">Auto-shuffle</div>
		<div class="control-group">
			<label class="control-label">Auto-shuffle</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-ashufflesvc" for="toggle-ashufflesvc-2">ON </label>$_select[ashufflesvc_on]
					<label class="toggle-radio toggle-ashufflesvc" for="toggle-ashufflesvc-1">OFF</label>$_select[ashufflesvc_off]
				</div>
				<button id="btn-set-ashufflesvc" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_ashufflesvc" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-ashufflesvc" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-ashufflesvc" class="config-help-info">
					When the last song in the Queue has finished playing, Auto-shuffle adds two randomly selected songs from the music library
					to the end of the Queue then repeats the process. This creates a continuous stream of music without growing the Queue and
					having two tracks enables MPD Crossfade to be used. NOTE: Auto-shuffle replaces MPD random play as the method for the 'Random' button.
                </span>
			</div>

			<label class="control-label" for="ashuffle-mode">Mode</label>
			<div class="controls">
				<select id="ashuffle-mode" class="config-select-large" name="ashuffle_mode" onchange="autoClick('#btn-set-ashuffle-mode');">
					$_select[ashuffle_mode]
				</select>
				<button id="btn-set-ashuffle-mode" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_ashuffle_mode" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_ashuffle_mode" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_ashuffle_mode" class="config-help-info">
					Play randomly selected track or whole album.
				</span>
			</div>

			<label class="control-label" for="ashuffle-window">Window size</label>
			<div class="controls">
                <input class="config-input-large" type="number" maxlength="3" min="1" max="1024" id="ashuffle-window" name="ashuffle_window" value="$_ashuffle_window" required>
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_ashuffle_window" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-ashuffle-window" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-ashuffle-window" class="config-help-info">
					Sets the size of the "window" used for the shuffle algorithm.
					Lower numbers mean more frequent repeats, and higher numbers mean less frequent repeats.
					The default window size is 7.
                </span>
			</div>

			<label class="control-label" for="ashuffle-filter">Tag filter</label>
			<div class="controls">
                <input class="config-input-large" type="text" id="ashuffle-filter" name="ashuffle_filter" value="$_ashuffle_filter">
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_ashuffle_filter" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_ashuffle_filter" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_ashuffle_filter" class="config-help-info">
					String of TAG VALUE pairs that Auto-shuffle uses to select the tracks being shuffled.
					Only one occurrence of a given TAG is allowed. The filter is case insensitive and it performs a TAG contains VALUE substring match.<br>
					<b>Ex:</b> genre "indie rock" artist coldplay<br>
					<b>Ex:</b> filename "NAS/Music/Led Zeppelin"
                </span>
			</div>

			<label class="control-label" for="ashuffle-exclude">Tag exclude</label>
			<div class="controls">
                <input class="config-input-large" type="text" id="ashuffle-exclude" name="ashuffle_exclude" value="$_ashuffle_exclude">
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_ashuffle_exclude" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_ashuffle_exclude" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_ashuffle_exclude" class="config-help-info">
					String of TAG VALUE pairs that Auto-shuffle uses to exclude the tracks being shuffled.
					Only one occurrence of a given TAG is allowed. The filter is case insensitive and it performs a TAG contains VALUE substring match.<br>
					<b>Ex:</b> artist Koz<br>
                </span>
			</div>
		</div>

		<div class="config-horiz-rule">Volume control</div>
		<div class="control-group">
			<label class="control-label" for="volume-step-limit">Volume step limit</label>
			<div class="controls">
				<select id="volume-step-limit" class="config-select-large" name="volume_step_limit" onchange="autoClick('#btn-set-volume-step-limit');">
					$_select[volume_step_limit]
				</select>
				<button id="btn-set-volume-step-limit" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_volume_step_limit" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_volume_step_limit" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_volume_step_limit" class="config-help-info">
					Sets the maximum amount the volume knob will advance when it's clicked ahead of its current position.
				</span>
			</div>

			<label class="control-label" for="volume-mpd-max">Max MPD volume</label>
			<div class="controls">
                <input class="config-input-large" type="number" maxlength="3" min="1" max="100" id="volume-mpd-max" name="volume_mpd_max" value="$_volume_mpd_max" required>
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_volume_mpd_max" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_volume_mpd_max" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_volume_mpd_max" class="config-help-info">
					Establishes the highest Volume Knob level that can be set.
                </span>
			</div>

			<label class="control-label">Display dB volume</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-volume-db-display" for="toggle-volume-db-display-2">ON </label>$_select[volume_db_display_on]
					<label class="toggle-radio toggle-volume-db-display" for="toggle-volume-db-display-1">OFF</label>$_select[volume_db_display_off]
				</div>
				<button id="btn-set-volume-db-display" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_volume_db_display" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_volume_db_display" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_volume_db_display" class="config-help-info">
					Display dB volume next to the 0-100 level in the volume knob.
                </span>
			</div>
		</div>

		<div class="config-horiz-rule">MPD DSP</div>
		<p class="sub-legend">
			Note that Core DSP, Crossfeed, and Polarity inversion are mutually exclusive. Enabling one will disable the others.
		</p>

		<div class="control-group">
			<label class="control-label" for="mpdcrossfade">Crossfade (secs)</label>
			<div class="controls">
                <input class="config-input-large" type="number" maxlength="2" min="0" max="15" id="mpdcrossfade" name="mpdcrossfade" value="$_mpdcrossfade" required>
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_mpdcrossfade" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-mpdcrossfade" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-mpdcrossfade" class="config-help-info">
					The MPD Audio buffer must be large enough to perform the requested number of seconds of crossfade for a given audio format. Set to 0 to disable crossfade.
                </span>
			</div>

			<label class="control-label" for="crossfeed">Crossfeed</label>
			<div class="controls">
				<select id="crossfeed" class="config-select-large" name="crossfeed" onchange="autoClick('#btn-set-crossfeed');" $_crossfeed_ctl_disabled>
					$_select[crossfeed]
				</select>
				<button id="btn-set-crossfeed" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_crossfeed" value="novalue" $_crossfeed_ctl_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-crossfeed" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-crossfeed" class="config-help-info">
					<b>700 Hz, 3.0 dB - Linkwitz</b><br>
					- Approximates an original Linkwitz crossfeeder with azimuth 40 degrees. Highest crossfeed level, lowest separation.<br>
					<b>700 Hz, 4.5 dB - Bauer</b><br>
					- Approximates a virtual speaker placement with azimuth 30 degrees at about 3 meters distance.<br>
					<b>800 Hz, 6.0 dB - Chu Moy</b><br>
					- Approximates a Chu Moy modified Linkwitz crossfeeder.<br>
					<b>730 Hz, 6.2 dB - Liqube</b><br>
					- Approximates Resonic's fine-tuned "Liqube" crossfeeder.<br>
					<b>650 Hz, 9.5 dB - Jan Meier</b><br>
					- Approximates a Jan Meier natural crossfeeder. Lowest crossfeed level, highest separation.<br>
                </span>
			</div>

			<label class="control-label">Polarity inversion</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-invert-polarity" for="toggle-invert-polarity-2">ON </label>$_select[invert_polarity_on]
					<label class="toggle-radio toggle-invert-polarity" for="toggle-invert-polarity-1">OFF</label>$_select[invert_polarity_off]
				</div>
				<button id="btn-set-invert-polarity" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_invert_polarity" value="novalue" $_invpolarity_ctl_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info_invert_polarity" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info_invert_polarity" class="config-help-info">
					Change the waveform on each channel from +/- to -/+.<br>
                </span>
			</div>
		</div>

		<div class="config-horiz-rule">HTTP streaming</div>
		<div class="control-group">
			<label class="control-label">Streaming server</label>
			<div class="controls">
				<div class="toggle">
					<label class="toggle-radio toggle-mpd-httpd" for="toggle-mpd-httpd-2">ON </label>$_select[mpd_httpd_on]
					<label class="toggle-radio toggle-mpd-httpd" for="toggle-mpd-httpd-1">OFF</label>$_select[mpd_httpd_off]
				</div>
				<button id="btn-set-mpd-httpd" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_mpd_httpd" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-mpd-httpd" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-mpd-httpd" class="config-help-info">
					Provide MPD output as an HTTP stream on the designated port.<br>
                </span>
			</div>

			<label class="control-label" for="mpd-httpd-port">Port</label>
			<div class="controls">
                <input class="config-input-large" type="number" maxlength="4" min="8000" max="9000" id="mpd-httpd-port" name="mpd_httpd_port" value="$_mpd_httpd_port" required>
				<button class="btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_mpd_httpd_port" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-mpd-httpd-port" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-mpd-httpd-port" class="config-help-info">
					Default port is 8000. Port number range is 8000 - 9000.
                </span>
			</div>

			<label class="control-label" for="mpd-httpd-encoder">Encoder</label>
			<div class="controls">
				<select id="mpd-httpd-encoder" class="config-select-large" name="mpd_httpd_encoder" onchange="autoClick('#btn-set-mpd-httpd-encoder');">
					$_select[mpd_httpd_encoder]
				</select>
				<button id="btn-set-mpd-httpd-encoder" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_mpd_httpd_encoder" value="novalue"><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-mpd-httpd-encoder" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-mpd-httpd-encoder" class="config-help-info">
					Encode the stream using either FLAC at compression level 0 (fastest, least compression) or LAME (MP3) at 320 kbps.
				</span>
			</div>
		</div>

		<legend>CoreDSP</legend>
		<p class="sub-legend">
			CoreDSP supports MPD, Bluetooth, AirPlay, Spotify Connect, Deezer Connect and Squeezelite renderers.
			It is not available if Multiroom Sender or Receiver are On.
			Note that CoreDSP and MPD Crossfeed and Polarity inversion are mutually exclusive. Enabling one will disable the others.
		</p>

		<div class="config-horiz-rule">General Purpose DSP</div>
		<div class="control-group">
			<label class="control-label" for="cdsp-mode">CamillaDSP</label>
			<div class="controls">
				<select id="cdsp-mode" class="config-select-large" name="cdsp_mode" onchange="autoClick('#btn-set-cdsp-mode');" $_cdsp_mode_ctl_disabled>
					$_select[cdsp_mode]
				</select>
				<button id="btn-set-cdsp-mode" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_cdsp_mode" value="novalue" $_cdsp_mode_ctl_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-cdsp-mode" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="cdsp-config-description" class="config-help-static config-help-less-margin">
					$_config_description<br>
					$_config_check
				</span>
				<span id="info-cdsp-mode" class="config-help-info">
					CamillaDSP is a general purpose Digital Signal Processing engine for routing and filtering sound. It can be used for building crossovers for active speakers, performing room correction, equalization or volume control. CamillaDSP is maintained by Henrik Enquist. Integration into moOde was done by @bitlab.<br>
					Feature summary:<br>
					- IIR filters (BiQuad)<br>
					- FIR filters (Convolution via FFT)<br>
					- Built-in sample rate converter<br>
					- Filters can be chained freely<br>
					- Flexible routing<br>
					- Simple YAML configuration<br>
					- All calculations done with 64-bit floats<br>
					- ARM Neon 64-bit instruction set is used<br>
					- Pipeline editor with expert mode<br>
					Configurations can be managed at the CamillaDSP settings page.
                </span>
			</div>

			<div class="controls">
				<a href="cdsp-config.php"><button class="btn btn-medium btn-primary config-btn" $_cdsp_mode_ctl_disabled>Edit</button></a>
				<span class="config-btn-after">CamillaDSP settings</span>
			</div>
		</div>

		<div class="config-horiz-rule">ALSA Equalizers</div>
		<p class="sub-legend">
			Note: Peppy display cannot be turned on if playing to a Bluetooth speaker with Graphic or Parameteic EQ on.
		</p>

		<label class="control-label" for="alsaequal">Graphic EQ</label>
		<div class="controls">
			<select id="alsaequal" class="config-select-large" name="alsaequal" onchange="autoClick('#btn-set-alsaequal');" $_alsaequal_ctl_disabled>
				$_select[alsaequal]
			</select>
			<button id="btn-set-alsaequal" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_alsaequal" value="novalue" $_alsaequal_ctl_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
			<a aria-label="Help" class="config-info-toggle" data-cmd="info-alsaequal" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
			<span id="info-alsaequal" class="config-help-info">
				A classic octave-band, constant-Q, second-order filter design.
				Frequency bands centered above Nyquist are automatically disabled.
				This EQ uses the Eq10X2 component of the C Audio Plugin Suite (CAPS) suite of DSP programs written by Tim Goetze.
			</span>
		</div>

		<div class="controls">
			<a href="eqg-config.php"><button class="btn btn-medium btn-primary config-btn">Edit</button></a>
			<span class="config-btn-after">EQ curve</span>
		</div>

		<div class="control-group">
			<label class="control-label" for="eqfa12p">Parametric EQ</label>
			<div class="controls">
				<select id="eqfa12p" class="config-select-large" name="eqfa12p" onchange="autoClick('#btn-set-eqfa12p');" $_eqfa12p_ctl_disabled>
					$_select[eqfa12p]
				</select>
				<button id="btn-set-eqfa12p" class="hide btn btn-primary btn-small config-btn-set btn-submit" type="submit" name="update_eqfa12p" value="novalue" $_eqfa12p_ctl_disabled><i class="fa fa-solid fa-sharp fa-arrow-turn-down-left"></i></button>
				<a aria-label="Help" class="config-info-toggle" data-cmd="info-eqp" href="#notarget"><i class="fa-regular fa-sharp fa-info-circle"></i></a>
				<span id="info-eqp" class="config-help-info">
					Twelve Mitra-Regalia peaking equaliser filters in series; a vector arithmetic re-implementation of Fons Adriaensens "Parametric1" equaliser[fafil] with minor differences.â€‚
					Parallelisation of the serial filter organisation causes the output to lag by three samples.
					This EQ uses the @bitlab eqfa12p plugin based on the eqfa4p plugin in the C Audio Plugin Suite (CAPS) suite of DSP programs written by Tim Goetze.
                </span>
			</div>

			<div class="controls">
				<a href="eqp-config.php"><button class="btn btn-medium btn-primary config-btn">Edit</button></a>
				<span class="config-btn-after">EQ curve</span>
			</div>
		</div>
	</form>
</div>
</div>

<form class="form-horizontal" method="post">
	<div id="mpd-restart" class="modal hide" tabindex="-1" role="dialog" aria-labelledby="mpd-restart-label" aria-hidden="true">
		<div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
			<h3>Restart MPD service?</h3>
		</div>
		<div class="modal-body"></div>
		<div class="modal-footer">
			<button class="btn" data-dismiss="modal" aria-hidden="true">Cancel</button>
			<button class="btn btn-primary btn-submit" type="submit" name="mpdrestart" value="1">Yes</button>
		</div>
	</div>
</form>

<!-- Room Correction Wizard Modal -->
<div id="room-correction-wizard-modal" class="modal hide" tabindex="-1" role="dialog" aria-labelledby="room-correction-wizard-label" aria-hidden="true">
	<div class="modal-dialog modal-lg" role="document">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
				<h4 class="modal-title">Room Correction Wizard</h4>
			</div>
			<div class="modal-body">
				<!-- Step 1: Instructions -->
				<div id="wizard-step-1" class="wizard-step">
					<h5>Step 1: Vorbereitung</h5>
					<ol>
						<li>Positioniere dein Smartphone am HÃ¶rplatz</li>
						<li><strong>Stelle sicher, dass Mikrofon-Zugriff erlaubt ist</strong>
							<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 8px; margin: 8px 0 8px 20px; font-size: 0.9em;">
								<strong>iPhone:</strong> Einstellungen â†’ Safari â†’ Mikrofon â†’ Finde deine IP-Adresse (z.B. 192.168.x.x) â†’ "Erlauben"<br>
								<small>Der Browser wird auch nach Zugriff fragen, wenn du "Start Measurement" klickst.</small>
							</div>
						</li>
						<li>Reduziere UmgebungsgerÃ¤usche soweit mÃ¶glich</li>
					</ol>
					<button class="btn btn-primary btn-medium" onclick="wizardNextStep()">Start Measurement</button>
				</div>

				<!-- Step 2: Ambient Noise Measurement -->
				<div id="wizard-step-2" class="wizard-step" style="display: none;">
					<h5>Step 2: Ambient Noise Measurement</h5>
					<p><strong>Wichtig:</strong> Messe zuerst den UmgebungsgerÃ¤uschpegel. Stelle sicher, dass keine Musik oder Test-TÃ¶ne laufen.</p>
					<p>Das System wird jetzt die HintergrundgerÃ¤usche messen (5 Sekunden).</p>
					<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin: 10px 0;">
						<strong>ðŸ“± iPhone Microphone Permission:</strong><br>
						Wenn der Browser nach Mikrofon-Zugriff fragt, tippe auf <strong>"Erlauben"</strong>.<br>
						<small>Falls keine Abfrage erscheint: Einstellungen â†’ Safari â†’ Mikrofon â†’ deine IP-Adresse â†’ "Erlauben"</small>
					</div>
					<div id="noise-measurement-status">
						<p id="noise-measurement-status-text">Requesting microphone access...</p>
						<div id="noise-measurement-recording" style="display: none;">
							<p>ðŸ”´ Measuring ambient noise... (please be quiet)</p>
							<canvas id="ambient-noise-canvas" width="600" height="300"></canvas>
							<p id="noise-measurement-info" style="margin-top: 10px; font-size: 12px; color: #666;">
								Measuring for <span id="noise-measurement-time">5</span> seconds... This will be subtracted from the final measurement.
							</p>
							<button class="btn btn-primary btn-medium" onclick="finishNoiseMeasurement()" style="margin-top: 15px; display: none;" id="finish-noise-btn">Continue to Pink Noise Measurement</button>
						</div>
					</div>
				</div>

				<!-- Step 3: Continuous Measurement with Pink Noise -->
				<div id="wizard-step-3" class="wizard-step" style="display: none;">
					<h5>Step 3: Continuous Measurement with Pink Noise</h5>
					<p>Pink noise is playing continuously. Position your iPhone microphone at your listening position.</p>
					<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin: 10px 0;">
						<strong>ðŸ”Š Volume Control:</strong><br>
						Please set the volume to a comfortable level BEFORE starting the measurement. Pink noise will play at the current system volume level.
					</div>
					<div style="background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin: 10px 0;">
						<strong>ðŸ“± Microphone Permission:</strong><br>
						Der Browser fragt erneut nach Mikrofon-Zugriff. Tippe auf <strong>"Erlauben"</strong>.
					</div>
					<div id="measurement-status">
						<p id="measurement-status-text">Starting pink noise and requesting microphone access...</p>
						<div id="measurement-recording" style="display: none;">
							<p>ðŸ”´ Measuring... (2-3 second rolling average)</p>
							<canvas id="frequency-response-canvas" width="600" height="300"></canvas>
							<p id="measurement-info" style="margin-top: 10px; font-size: 12px; color: #666;">
								Measurement is continuously updated. Click "Apply Correction" when satisfied.
							</p>
							<button class="btn btn-primary btn-medium" onclick="applyCorrection()" style="margin-top: 15px;">Apply Correction</button>
							<button class="btn btn-danger btn-medium" onclick="stopMeasurement()" style="margin-top: 15px; margin-left: 10px;">Stop Measurement</button>
						</div>
					</div>
				</div>

				<!-- Step 4: Upload Measurement -->
				<div id="wizard-step-4" class="wizard-step" style="display: none;">
					<h5>Step 4: Messung hochladen</h5>
					<p>WÃ¤hle die aufgenommene Messung aus oder verwende Browser-Messung:</p>
					<div>
						<input type="file" id="measurement-file" accept="audio/wav,audio/wave" />
						<button class="btn btn-primary btn-medium" onclick="uploadMeasurement()">Upload Measurement</button>
					</div>
					<div id="browser-measurement" style="margin-top: 20px;">
						<button class="btn btn-primary btn-medium" onclick="startBrowserMeasurement()">Browser-basierte Messung</button>
						<div id="browser-recording-status" style="display: none;">
							<p>ðŸ”´ Recording...</p>
							<button class="btn btn-danger" onclick="stopBrowserMeasurement()">Stop Recording</button>
						</div>
					</div>
				</div>

				<!-- Step 5: Analyze & Generate -->
				<div id="wizard-step-5" class="wizard-step" style="display: none;">
					<h5>Step 5: Analyse & Filter-Generierung</h5>
					<div id="frequency-response-graph">
						<canvas id="analysis-canvas" width="600" height="300"></canvas>
					</div>
					<div>
						<label>Target Curve:</label>
						<select id="target-curve" class="config-select-large">
							<option value="flat">Flat (0 dB)</option>
							<option value="house_curve">House Curve (Harman Target)</option>
						</select>
					</div>
					<button class="btn btn-primary btn-medium" onclick="generateFilter()">Generate Filter</button>
				</div>

				<!-- Step 6: Apply & Test -->
				<div id="wizard-step-6" class="wizard-step" style="display: none;">
					<h5>Step 6: Filter anwenden</h5>
					<div id="before-after-graph">
						<canvas id="before-after-canvas" width="600" height="300"></canvas>
					</div>
					<div>
						<label>Preset Name:</label>
						<input type="text" id="preset-name" class="config-input-large" value="room_correction_<?php echo date('Y-m-d_H-i-s'); ?>" />
					</div>
					<button class="btn btn-primary btn-medium" onclick="applyFilter()">Apply Filter</button>
					<button class="btn btn-secondary btn-medium" onclick="testAB()">A/B Test</button>
				</div>
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
			</div>
		</div>
	</div>
</div>

<script>
let wizardStep = 1;
let measurementData = null;
let frequencyResponse = null;

// Web Audio API variables for continuous measurement
let audioContext = null;
let analyser = null;
let microphone = null;
let measurementInterval = null;
let isMeasuring = false;

// Rolling average buffer (2-3 seconds of data)
const SAMPLE_RATE = 44100;
const FFT_SIZE = 8192;
const AVERAGE_WINDOW_SECONDS = 2.5; // 2-3 second average
const NOISE_MEASUREMENT_SECONDS = 5; // Measure ambient noise for 5 seconds
const UPDATE_INTERVAL_MS = 100; // Update display every 100ms
let frequencyDataBuffer = []; // Circular buffer for rolling average
let currentFrequencyResponse = null;

// Ambient noise measurement
let ambientNoiseMeasurement = null;
let noiseMeasurementStartTime = null;
let noiseMeasurementInterval = null;
let isMeasuringNoise = false;

function startRoomCorrectionWizard() {
	wizardStep = 1;
	
	// Show modal - try multiple methods for compatibility
	var modal = $('#room-correction-wizard-modal');
	if (modal.length) {
		// Try Bootstrap modal first
		if (typeof $.fn.modal !== 'undefined') {
			modal.modal('show');
		} else {
			// Fallback: show directly
			modal.css('display', 'block');
			modal.addClass('show');
			// Add backdrop
			if (!$('#modal-backdrop').length) {
				$('body').append('<div id="modal-backdrop" class="modal-backdrop fade show"></div>');
			}
		}
	} else {
		// Pure JavaScript fallback
		var modalEl = document.getElementById('room-correction-wizard-modal');
		if (modalEl) {
			modalEl.style.display = 'block';
			modalEl.classList.add('show');
			if (!document.getElementById('modal-backdrop')) {
				var backdrop = document.createElement('div');
				backdrop.id = 'modal-backdrop';
				backdrop.className = 'modal-backdrop fade show';
				document.body.appendChild(backdrop);
			}
		} else {
			alert('Error: Wizard modal not found');
			return;
		}
	}
	
	showWizardStep(1);
	
	// Stop any existing measurement when modal is opened
	stopMeasurement();
}

function wizardNextStep() {
	wizardStep++;
	if (wizardStep === 2) {
		startNoiseMeasurement();
	} else if (wizardStep === 3) {
		startContinuousMeasurement();
	} else if (wizardStep === 4) {
		showWizardStep(4);
	}
}

function showWizardStep(step) {
	for (let i = 1; i <= 6; i++) {
		$('#wizard-step-' + i).hide();
	}
	$('#wizard-step-' + step).show();
	wizardStep = step;
}

function startNoiseMeasurement() {
	showWizardStep(2);
	$('#noise-measurement-status-text').text('Requesting microphone access for ambient noise measurement...');
	
	// Request microphone access and start noise measurement (no pink noise)
	startNoiseWebAudioMeasurement();
}

function startNoiseWebAudioMeasurement() {
	// Request microphone access
	navigator.mediaDevices.getUserMedia({ audio: true })
		.then(stream => {
			try {
				// Create AudioContext
				audioContext = new (window.AudioContext || window.webkitAudioContext)({
					sampleRate: SAMPLE_RATE
				});
				
				// Create analyser node
				analyser = audioContext.createAnalyser();
				analyser.fftSize = FFT_SIZE;
				analyser.smoothingTimeConstant = 0.3;
				
				// Connect microphone to analyser
				microphone = audioContext.createMediaStreamSource(stream);
				microphone.connect(analyser);
				
				// Initialize noise measurement
				ambientNoiseMeasurement = null;
				noiseMeasurementStartTime = Date.now();
				isMeasuringNoise = true;
				
				// Show measurement UI
				if (typeof jQuery !== 'undefined') {
					jQuery('#noise-measurement-recording').show();
					jQuery('#noise-measurement-status-text').text('âœ… Measuring ambient noise...');
				} else {
					var recordingEl = document.getElementById('noise-measurement-recording');
					var statusEl = document.getElementById('noise-measurement-status-text');
					if (recordingEl) recordingEl.style.display = 'block';
					if (statusEl) statusEl.textContent = 'âœ… Measuring ambient noise...';
				}
				
				// Start noise measurement loop
				noiseMeasurementInterval = setInterval(updateNoiseMeasurement, UPDATE_INTERVAL_MS);
				
				// Auto-finish after NOISE_MEASUREMENT_SECONDS
				setTimeout(function() {
					if (isMeasuringNoise) {
						finishNoiseMeasurement();
					}
				}, NOISE_MEASUREMENT_SECONDS * 1000);
				
				// Initial update
				updateNoiseMeasurement();
				
			} catch (err) {
				console.error('Error setting up Web Audio API:', err);
				alert('Error setting up audio measurement: ' + err.message);
			}
		})
		.catch(err => {
			console.error('Error accessing microphone:', err);
			var errorMsg = 'Microphone access denied or not available.\n\n';
			errorMsg += 'iPhone: Settings â†’ Safari â†’ Microphone â†’ Find your site â†’ Allow\n\n';
			errorMsg += 'Error: ' + err.message;
			alert(errorMsg);
			if (typeof jQuery !== 'undefined') {
				jQuery('#noise-measurement-status-text').html('âŒ Microphone access required<br><small>iPhone: Settings â†’ Safari â†’ Microphone</small>');
			}
		});
}

function updateNoiseMeasurement() {
	if (!analyser || !isMeasuringNoise) return;
	
	// Get frequency data
	const bufferLength = analyser.frequencyBinCount;
	const dataArray = new Uint8Array(bufferLength);
	analyser.getByteFrequencyData(dataArray);
	
	// Convert to dB and map to frequencies
	const frequencies = [];
	const magnitudes = [];
	const nyquist = SAMPLE_RATE / 2;
	
	for (let i = 0; i < bufferLength; i++) {
		const freq = (i * nyquist) / bufferLength;
		if (freq >= 20 && freq <= 20000) {
			const magnitude = dataArray[i];
			const db = magnitude > 0 ? (magnitude / 255) * 96 - 96 : -96;
			
			frequencies.push(freq);
			magnitudes.push(db);
		}
	}
	
	// Store current measurement (will be averaged)
	if (!ambientNoiseMeasurement) {
		ambientNoiseMeasurement = {
			frequencies: frequencies,
			magnitude: new Array(frequencies.length).fill(0),
			count: 0
		};
	}
	
	// Accumulate for average
	if (ambientNoiseMeasurement.frequencies.length === frequencies.length) {
		for (let i = 0; i < frequencies.length; i++) {
			// Interpolate if needed
			ambientNoiseMeasurement.magnitude[i] += magnitudes[i];
		}
		ambientNoiseMeasurement.count++;
	}
	
	// Update display
	drawAmbientNoiseCanvas(frequencies, magnitudes);
	
	// Update timer
	const elapsed = (Date.now() - noiseMeasurementStartTime) / 1000;
	const remaining = Math.max(0, NOISE_MEASUREMENT_SECONDS - elapsed);
	if (typeof jQuery !== 'undefined') {
		jQuery('#noise-measurement-time').text(Math.ceil(remaining));
		if (remaining <= 0) {
			jQuery('#finish-noise-btn').show();
		}
	}
}

function drawAmbientNoiseCanvas(frequencies, magnitudes) {
	const canvas = document.getElementById('ambient-noise-canvas');
	if (!canvas || !frequencies || frequencies.length === 0) return;
	
	const ctx = canvas.getContext('2d');
	const width = canvas.width;
	const height = canvas.height;
	const padding = 40;
	const graphWidth = width - (padding * 2);
	const graphHeight = height - (padding * 2);
	
	// Clear canvas
	ctx.clearRect(0, 0, width, height);
	
	// Draw background
	ctx.fillStyle = '#f5f5f5';
	ctx.fillRect(0, 0, width, height);
	
	// Find min/max for scaling
	let minDb = -80;
	let maxDb = -20;
	if (magnitudes && magnitudes.length > 0) {
		const actualMin = Math.min(...magnitudes);
		const actualMax = Math.max(...magnitudes);
		minDb = Math.min(minDb, Math.floor(actualMin / 5) * 5 - 5);
		maxDb = Math.max(maxDb, Math.ceil(actualMax / 5) * 5 + 5);
	}
	const dbRange = maxDb - minDb;
	
	// Draw grid
	ctx.strokeStyle = '#ddd';
	ctx.lineWidth = 1;
	
	// Horizontal lines (dB)
	for (let i = 0; i <= 10; i++) {
		const y = padding + (graphHeight / 10) * i;
		ctx.beginPath();
		ctx.moveTo(padding, y);
		ctx.lineTo(width - padding, y);
		ctx.stroke();
		
		const db = maxDb - (dbRange / 10) * i;
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		ctx.fillText(db.toFixed(0) + ' dB', 5, y + 4);
	}
	
	// Vertical lines (frequency, logarithmic)
	const freqLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
	for (let i = 0; i < freqLabels.length; i++) {
		const freq = freqLabels[i];
		const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
		ctx.beginPath();
		ctx.moveTo(x, padding);
		ctx.lineTo(x, height - padding);
		ctx.stroke();
		
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		const label = freq >= 1000 ? (freq / 1000) + 'k' : freq + '';
		ctx.fillText(label, x - 10, height - 10);
	}
	
	// Draw ambient noise curve
	if (frequencies && magnitudes) {
		ctx.strokeStyle = '#ff9800';
		ctx.lineWidth = 2;
		ctx.beginPath();
		
		for (let i = 0; i < frequencies.length; i++) {
			const freq = frequencies[i];
			const db = magnitudes[i];
			
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			const y = padding + ((maxDb - db) / dbRange) * graphHeight;
			
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		
		ctx.stroke();
	}
	
	// Label
	ctx.fillStyle = '#333';
	ctx.font = '12px Arial';
	ctx.textAlign = 'center';
	ctx.fillText('Ambient Noise Level', width / 2, 20);
	ctx.fillText('Frequency (Hz)', width / 2, height - 5);
	ctx.save();
	ctx.translate(15, height / 2);
	ctx.rotate(-Math.PI / 2);
	ctx.fillText('Amplitude (dB)', 0, 0);
	ctx.restore();
}

function finishNoiseMeasurement() {
	isMeasuringNoise = false;
	
	// Stop measurement interval
	if (noiseMeasurementInterval) {
		clearInterval(noiseMeasurementInterval);
		noiseMeasurementInterval = null;
	}
	
	// Calculate average ambient noise
	if (ambientNoiseMeasurement && ambientNoiseMeasurement.count > 0) {
		for (let i = 0; i < ambientNoiseMeasurement.magnitude.length; i++) {
			ambientNoiseMeasurement.magnitude[i] /= ambientNoiseMeasurement.count;
		}
		console.log('Ambient noise measured:', ambientNoiseMeasurement);
	}
	
	// Close audio context (will be recreated for pink noise measurement)
	if (audioContext) {
		audioContext.close().catch(console.error);
		audioContext = null;
	}
	analyser = null;
	microphone = null;
	
	// Advance to next step
	wizardNextStep();
}

function startContinuousMeasurement() {
	showWizardStep(3);
	$('#measurement-status-text').text('Starting pink noise playback...');
	
	// Start pink noise playback (continuous)
	$.post('/command/room-correction-wizard.php', {
		cmd: 'start_pink_noise'
	}, function(data) {
		if (data.status === 'ok') {
		jQuery('#measurement-status-text').text('Pink noise started. Requesting microphone access...');
		
		// Request microphone access and start measurement
		startWebAudioMeasurement();
	} else {
		alert('Failed to start pink noise: ' + data.message);
	}
	});
}

function startWebAudioMeasurement() {
	// Request microphone access
	navigator.mediaDevices.getUserMedia({ audio: true })
		.then(stream => {
			try {
				// Create AudioContext
				audioContext = new (window.AudioContext || window.webkitAudioContext)({
					sampleRate: SAMPLE_RATE
				});
				
				// Create analyser node
				analyser = audioContext.createAnalyser();
				analyser.fftSize = FFT_SIZE;
				analyser.smoothingTimeConstant = 0.3; // Less smoothing for real-time
				
				// Connect microphone to analyser
				microphone = audioContext.createMediaStreamSource(stream);
				microphone.connect(analyser);
				
				// Initialize frequency data buffer
				frequencyDataBuffer = [];
				
				// Show measurement UI
				if (typeof jQuery !== 'undefined') {
					jQuery('#measurement-recording').show();
					jQuery('#measurement-status-text').text('âœ… Measurement active');
				} else {
					var recordingEl = document.getElementById('measurement-recording');
					var statusEl = document.getElementById('measurement-status-text');
					if (recordingEl) recordingEl.style.display = 'block';
					if (statusEl) statusEl.textContent = 'âœ… Measurement active';
				}
				isMeasuring = true;
				
				// Start continuous measurement loop
				measurementInterval = setInterval(updateMeasurement, UPDATE_INTERVAL_MS);
				
				// Initial update
				updateMeasurement();
				
			} catch (err) {
				console.error('Error setting up Web Audio API:', err);
				alert('Error setting up audio measurement: ' + err.message);
			}
		})
		.catch(err => {
			console.error('Error accessing microphone:', err);
			var errorMsg = 'Microphone access denied or not available.\n\n';
			errorMsg += 'iPhone: Settings â†’ Safari â†’ Microphone â†’ Find your site â†’ Allow\n\n';
			errorMsg += 'Error: ' + err.message;
			alert(errorMsg);
			if (typeof jQuery !== 'undefined') {
				jQuery('#measurement-status-text').html('âŒ Microphone access required<br><small>iPhone: Settings â†’ Safari â†’ Microphone</small>');
			} else {
				var statusEl = document.getElementById('measurement-status-text');
				if (statusEl) statusEl.textContent = 'âŒ Microphone access required - iPhone: Settings â†’ Safari â†’ Microphone';
			}
		});
}

function updateMeasurement() {
	if (!analyser || !isMeasuring) return;
	
	// Get frequency data
	const bufferLength = analyser.frequencyBinCount;
	const dataArray = new Uint8Array(bufferLength);
	analyser.getByteFrequencyData(dataArray);
	
	// Convert to dB and map to frequencies
	const frequencies = [];
	const magnitudes = [];
	const nyquist = SAMPLE_RATE / 2;
	
	for (let i = 0; i < bufferLength; i++) {
		const freq = (i * nyquist) / bufferLength;
		// Only use 20-20000 Hz range
		if (freq >= 20 && freq <= 20000) {
			// Convert to dB (dataArray is 0-255, representing 0 to -96 dB)
			const magnitude = dataArray[i];
			const db = magnitude > 0 ? (magnitude / 255) * 96 - 96 : -96;
			
			frequencies.push(freq);
			magnitudes.push(db);
		}
	}
	
	// Add to rolling average buffer
	const timestamp = Date.now();
	frequencyDataBuffer.push({
		timestamp: timestamp,
		frequencies: frequencies,
		magnitudes: magnitudes
	});
	
	// Remove old data (keep only last 2-3 seconds)
	const cutoffTime = timestamp - (AVERAGE_WINDOW_SECONDS * 1000);
	frequencyDataBuffer = frequencyDataBuffer.filter(item => item.timestamp > cutoffTime);
	
	// Calculate rolling average
	if (frequencyDataBuffer.length > 0) {
		const avgMagnitudes = new Array(frequencies.length).fill(0);
		
		// Average across all samples in buffer
		frequencyDataBuffer.forEach(sample => {
			// Interpolate sample magnitudes to match frequency array
			for (let i = 0; i < frequencies.length; i++) {
				const targetFreq = frequencies[i];
				// Find closest frequency in sample
				let closestIdx = 0;
				let minDist = Math.abs(sample.frequencies[0] - targetFreq);
				for (let j = 1; j < sample.frequencies.length; j++) {
					const dist = Math.abs(sample.frequencies[j] - targetFreq);
					if (dist < minDist) {
						minDist = dist;
						closestIdx = j;
					}
				}
				avgMagnitudes[i] += sample.magnitudes[closestIdx];
			}
		});
		
		// Divide by number of samples
		for (let i = 0; i < avgMagnitudes.length; i++) {
			avgMagnitudes[i] /= frequencyDataBuffer.length;
		}
		
		// Subtract ambient noise if available
		let correctedMagnitudes = avgMagnitudes;
		if (ambientNoiseMeasurement && ambientNoiseMeasurement.frequencies.length === frequencies.length) {
			// Subtract noise floor from measurement
			// Use power subtraction: 10*log10(10^(signal/10) - 10^(noise/10))
			correctedMagnitudes = new Array(frequencies.length);
			for (let i = 0; i < frequencies.length; i++) {
				const signalPower = Math.pow(10, avgMagnitudes[i] / 10);
				const noisePower = Math.pow(10, ambientNoiseMeasurement.magnitude[i] / 10);
				const correctedPower = Math.max(0.000001, signalPower - noisePower); // Prevent negative/zero
				correctedMagnitudes[i] = 10 * Math.log10(correctedPower);
			}
		}
		
		// Store current averaged frequency response
		currentFrequencyResponse = {
			frequencies: frequencies,
			magnitude: correctedMagnitudes,
			ambient_noise: ambientNoiseMeasurement ? ambientNoiseMeasurement.magnitude : null
		};
		
		// Update display (show both original and corrected)
		drawFrequencyResponseCanvas(currentFrequencyResponse);
	}
}

function drawFrequencyResponseCanvas(freqResponse) {
	const canvas = document.getElementById('frequency-response-canvas');
	if (!canvas || !freqResponse) return;
	
	const ctx = canvas.getContext('2d');
	const width = canvas.width;
	const height = canvas.height;
	const padding = 40;
	const graphWidth = width - (padding * 2);
	const graphHeight = height - (padding * 2);
	
	// Clear canvas
	ctx.clearRect(0, 0, width, height);
	
	// Draw background
	ctx.fillStyle = '#f5f5f5';
	ctx.fillRect(0, 0, width, height);
	
	// Find min/max for scaling (including ambient noise if available)
	let minDb = -50;
	let maxDb = 0;
	const allMagnitudes = [...(freqResponse.magnitude || [])];
	if (freqResponse.ambient_noise && freqResponse.ambient_noise.length > 0) {
		allMagnitudes.push(...freqResponse.ambient_noise);
	}
	if (allMagnitudes.length > 0) {
		minDb = Math.min(...allMagnitudes);
		maxDb = Math.max(...allMagnitudes);
		minDb = Math.floor(minDb / 5) * 5 - 5; // Round down
		maxDb = Math.ceil(maxDb / 5) * 5 + 5; // Round up
	}
	const dbRange = maxDb - minDb;
	
	// Draw grid
	ctx.strokeStyle = '#ddd';
	ctx.lineWidth = 1;
	
	// Horizontal lines (dB)
	for (let i = 0; i <= 10; i++) {
		const y = padding + (graphHeight / 10) * i;
		ctx.beginPath();
		ctx.moveTo(padding, y);
		ctx.lineTo(width - padding, y);
		ctx.stroke();
		
		// dB labels
		const db = maxDb - (dbRange / 10) * i;
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		ctx.fillText(db.toFixed(0) + ' dB', 5, y + 4);
	}
	
	// Vertical lines (frequency, logarithmic)
	const freqLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
	for (let i = 0; i < freqLabels.length; i++) {
		const freq = freqLabels[i];
		const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
		ctx.beginPath();
		ctx.moveTo(x, padding);
		ctx.lineTo(x, height - padding);
		ctx.stroke();
		
		// Frequency labels
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		const label = freq >= 1000 ? (freq / 1000) + 'k' : freq + '';
		ctx.fillText(label, x - 10, height - 10);
	}
	
	// Draw ambient noise curve (if available, as reference)
	if (freqResponse.ambient_noise && freqResponse.frequencies && freqResponse.ambient_noise.length === freqResponse.frequencies.length) {
		ctx.strokeStyle = '#ff9800';
		ctx.lineWidth = 1;
		ctx.setLineDash([5, 5]);
		ctx.beginPath();
		
		for (let i = 0; i < freqResponse.frequencies.length; i++) {
			const freq = freqResponse.frequencies[i];
			const db = freqResponse.ambient_noise[i];
			
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			const y = padding + ((maxDb - db) / dbRange) * graphHeight;
			
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		
		ctx.stroke();
		ctx.setLineDash([]);
	}
	
	// Draw frequency response curve (corrected, with noise subtracted)
	if (freqResponse.frequencies && freqResponse.magnitude) {
		ctx.strokeStyle = '#007bff';
		ctx.lineWidth = 2;
		ctx.beginPath();
		
		for (let i = 0; i < freqResponse.frequencies.length; i++) {
			const freq = freqResponse.frequencies[i];
			const db = freqResponse.magnitude[i];
			
			// Logarithmic x-axis
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			// Linear y-axis (dB)
			const y = padding + ((maxDb - db) / dbRange) * graphHeight;
			
			if (i === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		}
		
		ctx.stroke();
	}
	
	// Draw 0 dB reference line
	ctx.strokeStyle = '#999';
	ctx.lineWidth = 1;
	ctx.setLineDash([5, 5]);
	const zeroY = padding + ((maxDb - 0) / dbRange) * graphHeight;
	ctx.beginPath();
	ctx.moveTo(padding, zeroY);
	ctx.lineTo(width - padding, zeroY);
	ctx.stroke();
	ctx.setLineDash([]);
	
	// Legend (if ambient noise is shown)
	if (freqResponse.ambient_noise) {
		ctx.fillStyle = '#333';
		ctx.font = '11px Arial';
		ctx.setLineDash([]);
		
		// Ambient noise
		ctx.strokeStyle = '#ff9800';
		ctx.lineWidth = 1;
		ctx.setLineDash([5, 5]);
		ctx.beginPath();
		ctx.moveTo(width - 180, 25);
		ctx.lineTo(width - 150, 25);
		ctx.stroke();
		ctx.setLineDash([]);
		ctx.fillText('Ambient Noise', width - 145, 30);
		
		// Corrected response
		ctx.strokeStyle = '#007bff';
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(width - 180, 45);
		ctx.lineTo(width - 150, 45);
		ctx.stroke();
		ctx.fillText('Corrected Response', width - 145, 50);
	}
}

function stopMeasurement() {
	isMeasuring = false;
	isMeasuringNoise = false;
	
	// Stop measurement intervals
	if (measurementInterval) {
		clearInterval(measurementInterval);
		measurementInterval = null;
	}
	if (noiseMeasurementInterval) {
		clearInterval(noiseMeasurementInterval);
		noiseMeasurementInterval = null;
	}
	
	// Stop audio context
	if (audioContext) {
		audioContext.close().catch(console.error);
		audioContext = null;
	}
	
	analyser = null;
	microphone = null;
	frequencyDataBuffer = [];
	
	// Stop pink noise
	if (typeof jQuery !== 'undefined') {
		jQuery.post('/command/room-correction-wizard.php', {
			cmd: 'stop_pink_noise'
		});
		jQuery('#measurement-recording').hide();
		jQuery('#noise-measurement-recording').hide();
		jQuery('#measurement-status-text').text('Measurement stopped');
		jQuery('#noise-measurement-status-text').text('Noise measurement stopped');
	}
}

function applyCorrection() {
	if (!currentFrequencyResponse) {
		alert('No measurement data available. Please wait for measurement to stabilize.');
		return;
	}
	
	// Send frequency response to backend for processing
	if (typeof jQuery === 'undefined') {
		alert('jQuery is not loaded');
		return;
	}
	jQuery('#measurement-status-text').text('Processing frequency response...');
	
	jQuery.post('/command/room-correction-wizard.php', {
		cmd: 'process_frequency_response',
		frequency_response: JSON.stringify(currentFrequencyResponse),
		target_curve: 'flat'
	}, function(data) {
		if (data.status === 'ok') {
			// Generate PEQ filter
			const presetName = 'room_correction_peq_' + new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
			
			jQuery.post('/command/room-correction-wizard.php', {
				cmd: 'generate_peq',
				preset_name: presetName,
				num_bands: 12
			}, function(peqData) {
				if (peqData.status === 'ok') {
					// Apply PEQ filter
					jQuery.post('/command/room-correction-wizard.php', {
						cmd: 'apply_peq',
						preset_name: presetName
					}, function(applyData) {
						if (applyData.status === 'ok') {
							// Stop pink noise after applying correction
							jQuery.post('/command/room-correction-wizard.php', {
								cmd: 'stop_pink_noise'
							}, function(stopData) {
								console.log('Pink noise stopped after applying correction');
							}).fail(function(err) {
								console.error('Failed to stop pink noise:', err);
							});
							
							alert('Room correction applied successfully! Pink noise stopped.');
							// Stop measurement
							stopMeasurement();
						} else {
							alert('Error applying filter: ' + applyData.message);
						}
					});
				} else {
					alert('Error generating PEQ filter: ' + peqData.message);
				}
			});
		} else {
			alert('Error processing frequency response: ' + data.message);
		}
	});
}

function uploadMeasurement() {
	const fileInput = document.getElementById('measurement-file');
	if (!fileInput.files.length) {
		alert('Bitte wÃ¤hle eine Messung aus');
		return;
	}
	
	const formData = new FormData();
	formData.append('measurement', fileInput.files[0]);
	formData.append('cmd', 'upload_measurement');
	
	if (typeof jQuery === 'undefined') {
		alert('jQuery is not loaded');
		return;
	}
	jQuery.ajax({
		url: '/command/room-correction-wizard.php',
		type: 'POST',
		data: formData,
		processData: false,
		contentType: false,
		success: function(data) {
			if (data.status === 'ok') {
				analyzeMeasurement();
			} else {
				alert('Error: ' + data.message);
			}
		}
	});
}

let mediaRecorder = null;
let audioChunks = [];

function startBrowserMeasurement() {
	// Use Web Audio API for browser-based measurement
	navigator.mediaDevices.getUserMedia({ audio: true })
		.then(stream => {
			if (typeof jQuery !== 'undefined') {
				jQuery('#browser-recording-status').show();
			} else {
				var el = document.getElementById('browser-recording-status');
				if (el) el.style.display = 'block';
			}
			mediaRecorder = new MediaRecorder(stream);
			audioChunks = [];
			
			mediaRecorder.ondataavailable = function(event) {
				audioChunks.push(event.data);
			};
			
			mediaRecorder.onstop = function() {
				const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
				const formData = new FormData();
				formData.append('measurement', audioBlob, 'browser-measurement.wav');
				formData.append('cmd', 'upload_measurement');
				
				if (typeof jQuery === 'undefined') {
					alert('jQuery is not loaded');
					return;
				}
				jQuery.ajax({
					url: '/command/room-correction-wizard.php',
					type: 'POST',
					data: formData,
					processData: false,
					contentType: false,
					success: function(data) {
						if (data.status === 'ok') {
							analyzeMeasurement();
						} else {
							alert('Error: ' + data.message);
						}
					}
				});
				
				stream.getTracks().forEach(track => track.stop());
			};
			
			mediaRecorder.start();
		})
		.catch(err => {
			alert('Mikrofon-Zugriff verweigert: ' + err.message);
		});
}

function stopBrowserMeasurement() {
	if (mediaRecorder && mediaRecorder.state !== 'inactive') {
		mediaRecorder.stop();
		if (typeof jQuery !== 'undefined') {
			jQuery('#browser-recording-status').hide();
		} else {
			var el = document.getElementById('browser-recording-status');
			if (el) el.style.display = 'none';
		}
	}
}

function analyzeMeasurement() {
	if (typeof jQuery === 'undefined') {
		alert('jQuery is not loaded');
		return;
	}
	jQuery.post('/command/room-correction-wizard.php', {
		cmd: 'analyze_measurement'
	}, function(data) {
		if (data.status === 'ok') {
			frequencyResponse = data.frequency_response;
			showWizardStep(5);
			drawFrequencyResponse();
		}
	});
}

function generateFilter() {
	const targetCurve = $('#target-curve').val();
	$.post('/command/room-correction-wizard.php', {
		cmd: 'generate_filter',
		target_curve: targetCurve
	}, function(data) {
		if (data.status === 'ok') {
			showWizardStep(6);
			drawBeforeAfter();
		}
	});
}

function applyFilter() {
	const presetName = $('#preset-name').val();
	$.post('/command/room-correction-wizard.php', {
		cmd: 'apply_filter',
		preset_name: presetName
	}, function(data) {
		if (data.status === 'ok') {
			alert('Filter applied successfully!');
			$('#room-correction-wizard-modal').modal('hide');
			location.reload(); // Reload to show new preset
		}
	});
}

function toggleRoomCorrectionAB() {
	const currentState = $('#btn-room-correction-ab').data('enabled') || false;
	$.post('/command/room-correction-wizard.php', {
		cmd: 'toggle_ab_test',
		enabled: !currentState
	}, function(data) {
		if (data.status === 'ok') {
			$('#btn-room-correction-ab').data('enabled', data.enabled);
			$('#btn-room-correction-ab').text(data.enabled ? 'A/B: ON' : 'A/B: OFF');
		}
	});
}

function drawFrequencyResponse() {
	const canvas = document.getElementById('analysis-canvas');
	if (!canvas || !frequencyResponse) return;
	
	const ctx = canvas.getContext('2d');
	const width = canvas.width;
	const height = canvas.height;
	const padding = 40;
	const graphWidth = width - (padding * 2);
	const graphHeight = height - (padding * 2);
	
	// Clear canvas
	ctx.clearRect(0, 0, width, height);
	
	// Draw background
	ctx.fillStyle = '#f5f5f5';
	ctx.fillRect(0, 0, width, height);
	
	// Draw grid
	ctx.strokeStyle = '#ddd';
	ctx.lineWidth = 1;
	
	// Horizontal lines (dB)
	for (let i = 0; i <= 10; i++) {
		const y = padding + (graphHeight / 10) * i;
		ctx.beginPath();
		ctx.moveTo(padding, y);
		ctx.lineTo(width - padding, y);
		ctx.stroke();
		
		// dB labels
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		ctx.fillText((20 - i * 4) + ' dB', 5, y + 4);
	}
	
	// Vertical lines (frequency, logarithmic)
	const freqLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
	for (let i = 0; i < freqLabels.length; i++) {
		const freq = freqLabels[i];
		const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
		ctx.beginPath();
		ctx.moveTo(x, padding);
		ctx.lineTo(x, height - padding);
		ctx.stroke();
		
		// Frequency labels
		ctx.fillStyle = '#666';
		ctx.font = '10px Arial';
		ctx.fillText(freq >= 1000 ? (freq / 1000) + 'k' : freq + '', x - 10, height - 10);
	}
	
	// Draw frequency response curve
	if (frequencyResponse && typeof frequencyResponse === 'object') {
		ctx.strokeStyle = '#007bff';
		ctx.lineWidth = 2;
		ctx.beginPath();
		
		const freqs = Object.keys(frequencyResponse).map(Number).sort((a, b) => a - b);
		let firstPoint = true;
		
		freqs.forEach(freq => {
			const db = frequencyResponse[freq.toString()] || 0;
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			const y = padding + graphHeight - ((db + 20) / 40) * graphHeight;
			
			if (firstPoint) {
				ctx.moveTo(x, y);
				firstPoint = false;
			} else {
				ctx.lineTo(x, y);
			}
		});
		
		ctx.stroke();
		
		// Draw points
		ctx.fillStyle = '#007bff';
		freqs.forEach(freq => {
			const db = frequencyResponse[freq.toString()] || 0;
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			const y = padding + graphHeight - ((db + 20) / 40) * graphHeight;
			ctx.beginPath();
			ctx.arc(x, y, 3, 0, 2 * Math.PI);
			ctx.fill();
		});
	}
	
	// Draw axes labels
	ctx.fillStyle = '#333';
	ctx.font = '12px Arial';
	ctx.textAlign = 'center';
	ctx.fillText('Frequency (Hz)', width / 2, height - 5);
	ctx.save();
	ctx.translate(15, height / 2);
	ctx.rotate(-Math.PI / 2);
	ctx.fillText('Amplitude (dB)', 0, 0);
	ctx.restore();
}

function drawBeforeAfter() {
	const canvas = document.getElementById('before-after-canvas');
	if (!canvas || !frequencyResponse) return;
	
	const ctx = canvas.getContext('2d');
	const width = canvas.width;
	const height = canvas.height;
	const padding = 40;
	const graphWidth = width - (padding * 2);
	const graphHeight = height - (padding * 2);
	
	// Clear canvas
	ctx.clearRect(0, 0, width, height);
	
	// Draw background
	ctx.fillStyle = '#f5f5f5';
	ctx.fillRect(0, 0, width, height);
	
	// Draw grid (same as frequency response)
	ctx.strokeStyle = '#ddd';
	ctx.lineWidth = 1;
	
	for (let i = 0; i <= 10; i++) {
		const y = padding + (graphHeight / 10) * i;
		ctx.beginPath();
		ctx.moveTo(padding, y);
		ctx.lineTo(width - padding, y);
		ctx.stroke();
	}
	
	const freqLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
	for (let i = 0; i < freqLabels.length; i++) {
		const freq = freqLabels[i];
		const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
		ctx.beginPath();
		ctx.moveTo(x, padding);
		ctx.lineTo(x, height - padding);
		ctx.stroke();
	}
	
	// Draw BEFORE curve (red)
	if (frequencyResponse && typeof frequencyResponse === 'object') {
		ctx.strokeStyle = '#dc3545';
		ctx.lineWidth = 2;
		ctx.setLineDash([]);
		ctx.beginPath();
		
		const freqs = Object.keys(frequencyResponse).map(Number).sort((a, b) => a - b);
		let firstPoint = true;
		
		freqs.forEach(freq => {
			const db = frequencyResponse[freq.toString()] || 0;
			const x = padding + (Math.log10(freq / 20) / Math.log10(20000 / 20)) * graphWidth;
			const y = padding + graphHeight - ((db + 20) / 40) * graphHeight;
			
			if (firstPoint) {
				ctx.moveTo(x, y);
				firstPoint = false;
			} else {
				ctx.lineTo(x, y);
			}
		});
		
		ctx.stroke();
	}
	
	// Draw AFTER curve (green, flat target)
	ctx.strokeStyle = '#28a745';
	ctx.lineWidth = 2;
	ctx.setLineDash([5, 5]);
	ctx.beginPath();
	
	const targetFreqs = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
	const targetY = padding + graphHeight - ((0 + 20) / 40) * graphHeight; // 0 dB target
	
	ctx.moveTo(padding, targetY);
	ctx.lineTo(width - padding, targetY);
	ctx.stroke();
	
	// Legend
	ctx.fillStyle = '#333';
	ctx.font = '12px Arial';
	ctx.setLineDash([]);
	
	// Before
	ctx.strokeStyle = '#dc3545';
	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.moveTo(width - 150, 20);
	ctx.lineTo(width - 120, 20);
	ctx.stroke();
	ctx.fillStyle = '#333';
	ctx.fillText('Before (Measured)', width - 115, 25);
	
	// After
	ctx.strokeStyle = '#28a745';
	ctx.setLineDash([5, 5]);
	ctx.beginPath();
	ctx.moveTo(width - 150, 40);
	ctx.lineTo(width - 120, 40);
	ctx.stroke();
	ctx.setLineDash([]);
	ctx.fillText('After (Target)', width - 115, 45);
	
	// Axes labels
	ctx.fillStyle = '#333';
	ctx.textAlign = 'center';
	ctx.fillText('Frequency (Hz)', width / 2, height - 5);
	ctx.save();
	ctx.translate(15, height / 2);
	ctx.rotate(-Math.PI / 2);
	ctx.fillText('Amplitude (dB)', 0, 0);
	ctx.restore();
}

function toggleGhettoBlasterFlatEQ(enabled) {
	$.post('/command/ghettoblaster-flat-eq.php', {
		cmd: 'toggle',
		enabled: enabled ? 'true' : 'false'
	}, function(data) {
		if (data.status === 'ok') {
			// Show notification
			if (typeof showNotification === 'function') {
				showNotification('Flat EQ ' + (enabled ? 'aktiviert' : 'deaktiviert'));
			} else {
				alert('Flat EQ ' + (enabled ? 'aktiviert' : 'deaktiviert'));
			}
			// Optionally reload page to show updated state
			setTimeout(function() {
				location.reload();
			}, 1000);
		} else {
			alert('Error: ' + (data.message || 'Unknown error'));
		}
	}).fail(function() {
		alert('Failed to toggle Flat EQ');
	});
}

// Close modal function
function closeRoomCorrectionWizard() {
	stopMeasurement();
	var modal = $('#room-correction-wizard-modal');
	if (modal.length) {
		if (typeof $.fn.modal !== 'undefined') {
			modal.modal('hide');
		} else {
			modal.css('display', 'none');
			modal.removeClass('show');
		}
	}
	// Remove backdrop
	$('#modal-backdrop').remove();
	
	// Pure JavaScript fallback
	var modalEl = document.getElementById('room-correction-wizard-modal');
	if (modalEl) {
		modalEl.style.display = 'none';
		modalEl.classList.remove('show');
	}
	var backdrop = document.getElementById('modal-backdrop');
	if (backdrop) {
		backdrop.remove();
	}
}

// Initialize wizard when modal is shown (wait for jQuery)
if (typeof jQuery !== 'undefined') {
	jQuery(document).ready(function($) {
		$('#room-correction-wizard-modal').on('shown', function() {
			wizardStep = 1;
			showWizardStep(1);
			stopMeasurement();
			// Reset ambient noise measurement
			ambientNoiseMeasurement = null;
			isMeasuringNoise = false;
		});
		
		// Stop measurement when modal is closed
		$('#room-correction-wizard-modal').on('hidden', function() {
			stopMeasurement();
		});
	});
} else {
	// Fallback: wait for jQuery
	setTimeout(function() {
		if (typeof jQuery !== 'undefined') {
			jQuery(document).ready(function($) {
				$('#room-correction-wizard-modal').on('shown', function() {
					wizardStep = 1;
					showWizardStep(1);
					stopMeasurement();
				});
				$('#room-correction-wizard-modal').on('hidden', function() {
					stopMeasurement();
				});
			});
		}
	}, 500);
}
</script>
